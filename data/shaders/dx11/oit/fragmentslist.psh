#include <common.h>
#include <pscommon.h>

struct ListNode
{
	uint packedColor;
	float depth;
	uint next;
};
RWTexture2D<uint> headBuffer;
RWStructuredBuffer<ListNode> fragmentsList;

uint packColor(float4 color)
{
	return (uint(color.r * 255) << 24) | (uint(color.g * 255) << 16) | (uint(color.b * 255) << 8) | uint(color.a * 255);
}

[earlydepthstencil]
float4 main(VS_OUTPUT input) : SV_TARGET
{
	float3 color = computeColor(input);
	uint newHeadBufferValue = fragmentsList.IncrementCounter();
	if (newHeadBufferValue == 0xffffffff) { return float4(0, 0, 0, 0); }
	
	uint2 upos = uint2(input.position.xy);
	uint previosHeadBufferValue;
	InterlockedExchange(headBuffer[upos], newHeadBufferValue, previosHeadBufferValue);
	
	float currentDepth = input.uv0_depth.z;
	ListNode node;
	node.packedColor = packColor(float4(color, 0.5));
	node.depth = currentDepth;
	node.next = previosHeadBufferValue;
	
	if (previosHeadBufferValue == 0xffffffff)
	{
		fragmentsList[newHeadBufferValue] = node;
	}
	else
	{
		fragmentsList[newHeadBufferValue].next = previosHeadBufferValue;
		
		uint newIndex = newHeadBufferValue;
		uint nextIndex = previosHeadBufferValue;
		
		[unroll(15)]
		while (nextIndex != 0xffffffff)
		{
			ListNode n = fragmentsList[nextIndex];
			if (currentDepth < n.depth)
			{
				fragmentsList[newIndex].packedColor = n.packedColor;
				fragmentsList[newIndex].depth = n.depth;
				newIndex = nextIndex;
			}
			nextIndex = n.next;
		}
		
		fragmentsList[newIndex].packedColor = node.packedColor;
		fragmentsList[newIndex].depth = node.depth;
	}
	
	return float4(0, 0, 0, 0);
}