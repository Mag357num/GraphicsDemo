struct ListNode
{
	uint packedColor;
	float depth;
	uint next;
};
RWTexture2D<uint> headBuffer;
RWStructuredBuffer<ListNode> fragmentsList;

struct VS_OUTPUT
{
    float4 position : SV_POSITION;
};

float4 unpackColor(uint color)
{
	float4 output;
	output.r = float((color >> 24) & 0x000000ff) / 255.0f;
	output.g = float((color >> 16) & 0x000000ff) / 255.0f;
	output.b = float((color >> 8) & 0x000000ff) / 255.0f;
	output.a = float(color & 0x000000ff) / 255.0f;
	return saturate(output);
}

/*public static void insertionSort(int[] arr) {
    for(int i = 1; i < arr.length; i++){
        int currElem = arr[i];
        int prevKey = i - 1;
        while(prevKey >= 0 && arr[prevKey] > currElem){
            arr[prevKey+1] = arr[prevKey];
            prevKey--; 
        }
        arr[prevKey+1] = currElem;
    }
}*/

/*void insertionSort(uint startIndex)
{
	uint index = fragmentsList[startIndex].next;
	[unroll(15)]
	while (index != 0xffffffff)
	{
		uint nextIndex = fragmentsList[index].next;
		
		
		index = nextIndex;
	}
}*/

float4 main(VS_OUTPUT input) : SV_TARGET
{
	uint2 upos = uint2(input.position.xy);
	uint index = headBuffer[upos];

	float3 color = float3(0, 0, 0);
	float alpha = 1;
	
	[unroll(16)]
	while (index != 0xffffffff)
	{
		ListNode node = fragmentsList[index];
		float4 c = unpackColor(node.packedColor);
		alpha *= (1.0 - c.a);
		color = lerp(color, c.rgb, c.a);
		index = node.next;
	}
    return float4(color, alpha);
}